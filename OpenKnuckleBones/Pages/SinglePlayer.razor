@page "/single-player"
@using OpenKnuckleBones.Components
<h1>Single Player</h1>

Welcome to Single Player Knuckle Bones

<div>

    <!-- TODO: Implement Bot -->
    <div class="player top">
        <div class="player-dice">
            <Dice number=1 />
        </div>

        <Board rolled=false boardArr=@botArr dim=@_dim onColClick=@onColClick />
    </div>

    <div class="player bottom">
        <div class="player-dice">
            @if (@rolled) {
                <Dice number=@rollNum />
            } else {
                <button class="btn btn-primary" @onclick=onRollClick>Roll Dice</button>
            }

            <p>Total: @getTotal()</p>
        </div>

        <Board rolled=@rolled boardArr=@boardArr dim=@_dim onColClick=@onColClick/>
    </div>
</div>




@code {
    private short _rollNum = 0;
    private bool _rolled = false;
    private static short[] _dim = { 3, 3 };

    private short[,] _boardArr = new short[_dim[0], _dim[1]];

    private short[,] _botArr = new short[_dim[0], _dim[1]];

    private Random rnd = new Random();

    #region Getters/Setters

    public short rollNum {
        get {
            return _rollNum;
        }

        set {
            if(!_rolled) {
                _rollNum = value;
            }
        }
    }

    public bool rolled {
        get {
            return _rolled;
        }
    }

    public short[,] boardArr {
        get {
            return _boardArr;
        }
    }

    public short[,] botArr
    {
        get
        {
            return _botArr;
        }
    }

    #endregion

    #region Button Functions

    private void onRollClick() {
        rollNum = (short) (rnd.Next(5)+1);
        _rolled = true;
    }

    private void onColClick(short col) {

        --col;

        if(rolled) {
            turn(_boardArr, col, rollNum);
            _rolled = false;

            runBotsTurn();
        }
    }

    #endregion

    #region Helper Functions

    private void turn(short[,] arr, short col, short val) {
        short row = getLastIndex(arr, col);

        arr[row, col] = val;

    }

    private void runBotsTurn() {

        short botTurn = (short)(rnd.Next(5) + 1);
        short botCol = (short)(rnd.Next(3));

        turn(_botArr, botCol, botTurn);
    }

    private short getLastIndex(short[,] arr, short col) {
        for(short i = 0; i < arr.Length; i++) {
            if(arr[i, col] <= 0) {
                return i;
            }
        }

        return -1;
    }

    private short getTotal() {

        short total = 0;

        for(short i = 0; i < _dim[1]; i++) {
            total += getColTotal(i);
        }

        return total;
    }

    // Get Total of a column from _boardArr
    private short getColTotal(short col)
    {
        short total = 0;

        /* Rule: When one column has multiple of a single digit (I.E. 6),
                 that number is multiplied by the count of that digit.

           Ex:   If column 3 looks like the following [4,6,6] the column
                 score is ((6+6)x2)+4 = 28.
         */
        
        short[] colarr = getCol(col);

        short count = 0; // Keeps count of each digit in the column

        for (short i = 1; i <= 6; i++)
        {

            count = 0;

            for (short j = 0; j < _dim[0]; j++)
            {
                // if the current row (colarr[j]) == the current digit (i)
                if (colarr[j] == i)
                {
                    colarr[j] = 0; // Set to 0 so next rule won't use it in the sum
                    count++; // Increment count of digit i
                }
            }

            total += (short) (i * count * count); 
            /*
               Multiply count of i (digit) with the digit itself
               This works because if we were to have only 1, it's 1xi
               if we have 2 6's, it's 2x6 which follows the rule
            */
        }

        return total;
    }

    private short[] getCol(short col)
    {
        short[] newarr = new short[_dim[0]];

        for (short i = 0; i < _dim[0]; i++)
        {
            newarr[i] = _boardArr[i, col];
        }

        return newarr;
    }

    #endregion
}